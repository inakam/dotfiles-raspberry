# コードレビューチェックリスト

## A. シンプルさと可読性（Simplicity & Readability）

### 意図の明確化
- [ ] 変数名や関数名は、その中身を見なくても「何をするか」がわかるか
- [ ] 曖昧な名前（data, temp, manager, handler）を使用していないか
- [ ] プロジェクト全体で一貫した命名規則に従っているか
- [ ] ドメイン用語（ユビキタス言語）が適切に使用されているか

### 複雑性の排除
- [ ] ネストは浅く保たれているか（3段階以内が目安）
- [ ] ガード節（早期リターン）を使用して主要ロジックを平坦化できるか
- [ ] 1つの関数が1つのことだけを行っているか
- [ ] 関数の長さは適切か（20-30行以内が目安）
- [ ] サイクロマティック複雑度が高すぎないか

### YAGNI（過剰設計の排除）
- [ ] 現在の要件に不要な抽象化が含まれていないか
- [ ] 「将来のため」の未使用インターフェース/クラスがないか
- [ ] 使用されていない設定オプションやパラメータがないか
- [ ] 1つしか実装がないインターフェースは本当に必要か

### コメント
- [ ] コードで表現できることをコメントで説明していないか
- [ ] コメントは「Why（なぜ）」を説明しているか
- [ ] 古くなった嘘のコメントがないか

---

## B. 設計と拡張性（Design & Extensibility）

### 単一責任の原則（SRP）
- [ ] クラスや関数は単一の責務を持っているか
- [ ] 変更理由が複数あるクラスになっていないか
- [ ] 保存・検証・表示などが同一クラスに混在していないか

### 開放閉鎖の原則（OCP）
- [ ] 新機能追加時に既存コードの変更が最小限で済むか
- [ ] switch/if-elseチェーンが長くなっていないか
- [ ] Strategyパターン等で拡張可能な設計になっているか

### 結合度
- [ ] `new`で具象クラスを直接生成していないか
- [ ] 依存性の注入（DI）を活用しているか
- [ ] インターフェースに依存しているか（具象クラスではなく）
- [ ] 循環参照がないか

### DRY（重複排除）
- [ ] 類似のロジックが複数箇所に散在していないか
- [ ] ただし、早すぎる抽象化になっていないか（Rule of Three）
- [ ] コピペコードがないか

### 定数管理
- [ ] マジックナンバーがハードコードされていないか
- [ ] マジックストリングが定数化されているか
- [ ] 設定値が適切に外部化されているか

---

## C. パフォーマンスとスケーラビリティ（Scalability）

### N+1問題
- [ ] ループ内でDBクエリを実行していないか
- [ ] ループ内で外部APIを呼び出していないか
- [ ] Eager Loading（事前読み込み）が適用されているか
- [ ] バッチ処理で一括取得できないか

### アルゴリズム
- [ ] ネストされたループで全探索していないか（O(N²)以上）
- [ ] リストをSet/Mapに変換して探索を高速化できないか
- [ ] 大量データでの動作を考慮しているか

### リソース管理
- [ ] メモリリークの原因となるオブジェクト保持がないか
- [ ] リソースのクローズ忘れがないか（ファイル、DB接続等）
- [ ] キャッシュの無制限な成長がないか
- [ ] イベントリスナーの解除忘れがないか

### 並行処理
- [ ] 適切な同期処理（排他制御）が行われているか
- [ ] デッドロックの可能性がないか
- [ ] スレッドセーフな設計になっているか

---

## D. テスト（Testing）

### 振る舞いのテスト
- [ ] 内部実装ではなく外部仕様（振る舞い）をテストしているか
- [ ] プライベートメソッドを直接テストしていないか
- [ ] テスト名が仕様を表現しているか

### AAAパターン
- [ ] Arrange/Act/Assertに構造化されているか
- [ ] 各フェーズが視覚的に分離されているか
- [ ] 1つのテストで1つの概念のみを検証しているか

### モックの使用
- [ ] モックは外部境界（DB、API、ファイルシステム）に限定されているか
- [ ] ドメインロジックは実インスタンスでテストしているか
- [ ] 過剰なモック（The Mockery）になっていないか

### 網羅性
- [ ] 正常系だけでなく異常系もテストしているか
- [ ] エッジケース（Null、空リスト、境界値）をカバーしているか
- [ ] バグ修正時に回帰テストが追加されているか

### 独立性
- [ ] テスト間で状態を共有していないか
- [ ] 実行順序に依存していないか
- [ ] 時刻やランダム値が適切にモック/固定されているか
- [ ] Flaky Test（間欠的失敗）の原因がないか

---

## E. セキュリティ（Security）

### 入力検証
- [ ] 全ての外部入力が検証・サニタイズされているか
- [ ] SQLインジェクション対策（パラメータ化クエリ）が行われているか
- [ ] XSS対策（エスケープ処理）が行われているか
- [ ] パストラバーサル対策が行われているか

### 機密情報
- [ ] パスワード、APIキー、トークンがログに出力されていないか
- [ ] 機密情報がハードコードされていないか
- [ ] エラーメッセージに内部情報が漏洩していないか

### 権限管理
- [ ] 適切な認証（Authentication）チェックが行われているか
- [ ] 適切な認可（Authorization）チェックが行われているか
- [ ] 権限昇格の脆弱性がないか

---

## F. エラーハンドリング

### 例外処理
- [ ] 例外を握りつぶしていないか（空のcatchブロック）
- [ ] 適切なログ出力が行われているか
- [ ] 例外が適切に伝播またはラップされているか

### 堅牢性
- [ ] 外部サービス障害時のタイムアウトが設定されているか
- [ ] リトライ処理が適切に実装されているか
- [ ] サーキットブレーカーパターンが考慮されているか
- [ ] フォールバック処理があるか

---

## G. プロセス

### PRのサイズ
- [ ] 変更行数は200-400行以内に収まっているか
- [ ] 大きすぎる場合は分割を検討

### 自動化
- [ ] Linter/Formatterで検出できる問題は自動化されているか
- [ ] 人間は設計・ロジック・可読性に集中できているか

---

## クイックリファレンス

### レビュー時の質問

**シンプルさについて**
- 「このコードを初めて読む人が即座に理解できるか？」
- 「より簡潔に書く方法はないか？」

**設計について**
- 「この機能を追加/変更するとき、どこを修正する必要があるか？」
- 「このクラスの責務は何か？1文で説明できるか？」

**テストについて**
- 「このテストを読めば、この機能の仕様がわかるか？」
- 「リファクタリングしてもこのテストは通り続けるか？」

**パフォーマンスについて**
- 「データ量が100倍になったらどうなるか？」
- 「このループは何回実行されるか？」
