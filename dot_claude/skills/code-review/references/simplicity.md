# シンプルさと可読性（Simplicity & Readability）

## 目次

1. [認知的負荷の管理](#認知的負荷の管理)
2. [制御フローの簡素化](#制御フローの簡素化)
3. [変数スコープと状態管理](#変数スコープと状態管理)
4. [命名規則](#命名規則)
5. [コメントの適切な使用](#コメントの適切な使用)
6. [YAGNI原則](#yagni原則)

---

## 認知的負荷の管理

コードは人間によって読まれ、理解され、修正される時間が大半を占める。レビューの最優先基準は「他の開発者がこのコードを初めて読んだときに、即座に文脈と意図を理解できるか」とする。

### チェックポイント

- コードの意図が明確か
- 複雑なロジックが分解されているか
- 一度に追跡すべき情報量が適切か

---

## 制御フローの簡素化

### ネストの深さ

人間の短期記憶には限界がある。深くネストされた条件分岐やループ構造は認知的負担となる。

#### 悪い例

```python
def process_order(order):
    if order:
        if order.is_valid:
            if order.has_items:
                if order.payment_confirmed:
                    # 実際の処理
                    return process(order)
    return None
```

#### 良い例（ガード節使用）

```python
def process_order(order):
    if not order:
        return None
    if not order.is_valid:
        return None
    if not order.has_items:
        return None
    if not order.payment_confirmed:
        return None

    return process(order)
```

### 早期リターン（Early Return）

- 例外的なケースを関数の冒頭で処理
- 主要なロジック（ハッピーパス）をネストなしで記述
- 「アロー型」コード構造を回避

### サイクロマティック複雑度

- 一つの関数内の分岐経路が過多でないか監視
- 複雑度が高い関数は論理的な分割を検討

---

## 変数スコープと状態管理

### スコープの最小化

- 変数の宣言位置と使用位置を可能な限り近接させる
- 一時変数が関数冒頭で宣言され、遠くで使用される「一時フィールド」を回避

### 不変性の推奨

- 可変（Mutable）な状態の不必要な共有を避ける
- 可能な限り不変（Immutable）な設計を採用
- 純粋関数（Pure Function）へのリファクタリングを検討

### 副作用の制御

- 予期せぬ副作用（Side Effect）を引き起こす実装を特定
- 副作用がある場合は明示的にする

---

## 命名規則

### 原則

変数名、関数名、クラス名は「何であるか（What）」だけでなく「なぜ存在するのか（Why）」を語るべきとする。

### 避けるべき名前

- `data`, `temp`, `manager`, `handler` など汎用的で曖昧な名前
- 単一文字の変数名（ループカウンタ以外）
- 略語の過度な使用

### 良い命名の特徴

| 観点 | 悪い例 | 良い例 |
|------|--------|--------|
| 具体性 | `getUsers` | `getActiveUsersWithSubscription` |
| 条件の明示 | `check(x)` | `isValidEmail(email)` |
| 動作の明確化 | `process(data)` | `calculateTotalPrice(orderItems)` |

### 一貫性

- `fetch`, `retrieve`, `get` などの動詞がプロジェクト全体で統一された意味で使用されているか確認
- チーム内の命名規則に従っているか

### ドメイン言語

- ビジネスドメインの用語（ユビキタス言語）がコードに反映されているか
- 技術的な用語よりビジネス上の文脈を反映した名前を優先

---

## コメントの適切な使用

### 削除すべきコメント

コードの動作をそのまま説明するコメントは即座に削除を検討：

```python
# 悪い例
i += 1  # iを1増やす

# 悪い例
user.save()  # ユーザーを保存する
```

### コメントが許容されるケース

1. **「なぜ（Why）」の説明**
   - アルゴリズム選択の理由
   - 標準的アプローチを取らなかった背景

2. **回避策の明示**
   - ライブラリのバグ回避理由
   - 外部要因によるハック

3. **業務知識**
   - コードを読むだけでは理解できない複雑なビジネスルール
   - 法的制約の補足

### 自己文書化コードの追求

「コメントが必要なコードは、コード自体が不明瞭であることの証明」という認識を持つ。

---

## YAGNI原則

**You Aren't Gonna Need It** - シンプルさを阻害する最大の要因は開発者の「善意」による過剰な将来予測とする。

### 投機的な汎用性（Speculative Generality）

以下のパターンを警戒：

- 「将来、別のデータベースに対応する必要があるかもしれない」
- 「将来、このパラメータは可変になるかもしれない」
- 未使用のインターフェース、抽象クラス、設定オプション

### レビュー時の質問

1. 「現在、この機能を使用する具体的な呼び出し元は存在するか？」
2. 「この抽象化は、現在の要件を満たすために必要最小限のものか？」
3. 「将来の拡張が必要になった時点でリファクタリングするのでは遅いのか？」

### Rule of Three

- 最初から完璧な抽象化を目指さない
- 具体的な実装の積み重ねから帰納的に導き出す
- 3度同じコードが現れたらリファクタリングを検討

### 過剰エンジニアリングの兆候

- 使用されていない設定オプション
- 1つしか実装がないインターフェース
- 「念のため」のパラメータ
- 将来のための「拡張ポイント」

---

## サマリーテーブル

| チェック項目 | 悪い例 | 良い例 | レビューの視点 |
|------------|--------|--------|---------------|
| 命名 | `d = calculate(a, b)` | `daysOverdue = calculateOverdueDays(invoiceDate, currentDate)` | 変数名だけでロジックの目的が伝わるか？ |
| 制御フロー | 深いネスト | ガード節使用 | 正常系のロジックがインデントなしで読めるか？ |
| コメント | `// ユーザーを保存する` | コメントなしで関数名で自明にする | コード自体がドキュメントになっているか？ |
| 関数の長さ | 100行以上の巨大な関数 | 単一責任に基づいた20行以内の関数群 | 1つの関数が1つのことだけを行っているか？ |
